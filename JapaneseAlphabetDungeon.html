<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆãƒ€ãƒ³ã‚¸ãƒ§ãƒ³</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
    }
    #game {
      display: grid;
      grid-template-columns: repeat(10, 40px);
      grid-template-rows: repeat(10, 40px);
      margin: 20px auto;
      border: 2px solid #333;
      width: 400px;
      height: 400px;
    }
    .cell {
      width: 40px;
      height: 40px;
      border: 1px solid #ccc;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2em;
    }
    .player { background-color: #4CAF50; color: white; }
    .monster { background-color: #f44336; color: white; }
    .treasure { background-color: #ffeb3b; color: #333; }
    .potion { background-color: #2196F3; color: white; }
    .stairs { background-color: #9C27B0; color: white; }
    .wall { background-color: #999; }
    #event-log {
      max-width: 400px;
      margin: 20px auto;
      text-align: left;
      border: 1px solid #ddd;
      padding: 10px;
      height: 100px;
      overflow-y: auto;
      background: #fefefe;
    }
    .log-entry {
      cursor: pointer;
      color: #4CAF50;
      margin: 0;
    }
    .log-entry:hover {
      text-decoration: underline;
    }
    .accordion {
      max-width: 600px;
      margin: 10px auto;
      text-align: left;
      border: 1px solid #ccc;
      background: #f9f9f9;
    }
    .accordion h3 {
      margin: 0;
      padding: 10px;
      background: #eee;
      cursor: pointer;
    }
    .accordion-content {
      display: none;
      padding: 10px;
    }
    .sound-toggle {
      cursor: pointer;
      margin-left: 10px;
    }
    #letters-conquered {
      max-width: 400px;
      margin: 20px auto;
      border: 1px solid #ccc;
      padding: 10px;
      background-color: #fafafa;
    }
    .conquered-letter {
      display: inline-block;
      margin: 4px;
      padding: 6px 10px;
      border: 1px solid #999;
      border-radius: 4px;
      cursor: pointer;
      background-color: #e0ffe0;
    }
    .conquered-letter:hover {
      background-color: #c0ffc0;
    }
  </style>
</head>
<body>
  <h1>ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆãƒ€ãƒ³ã‚¸ãƒ§ãƒ³</h1>

  <div class="accordion">
    <h3 onclick="toggleAccordion()">éŠã³æ–¹</h3>
    <div class="accordion-content" id="instructions">
      <ul>
        <li><strongãƒ—</strong> = ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼</li>
        <li><strongå®</strong> = å®ç‰©</li>
        <li><strongè–¬</strong> = å›å¾©è–¬</li>
        <li><strongéš</strong> = æ¬¡ã®éšæ®µ</li>
        <li><strong>ã‚â€“ã‚“</strong> = ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ï¼ˆã‚¯ãƒªãƒƒã‚¯ã§èª¬æ˜ãŒèã‘ã¾ã™ï¼‰</li>
      </ul>
      <p>çŸ¢å°ã‚­ãƒ¼ã§ç§»å‹•ã—ã¾ã™ã€‚ã‚µã‚¤ã‚³ãƒ­ã‚’æŒ¯ã£ã¦ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã¨æˆ¦ã„ã€ã‚¢ã‚¤ãƒ†ãƒ ã‚’é›†ã‚ã¦æ·±ã„éšã«é€²ã¿ã¾ã—ã‚‡ã†ï¼</p>
    </div>
  </div>

  <div id="game"></div>

  <p id="status">çŸ¢å°ã‚­ãƒ¼ã§æ¢ç´¢ã‚’é–‹å§‹ï¼</p>
  <p>
    éš: <span id="level">ã‚</span> |
    ä½“åŠ›: <span id="health">100</span> |
    é˜²å¾¡: <span id="armor">0</span> |
    ã‚³ã‚¤ãƒ³: <span id="coins">0</span>
    <span class="sound-toggle" onclick="toggleSound()">ğŸ”Š</span>
  </p>

  <div id="dice-game" style="display:none;">
    <p>
      ã‚µã‚¤ã‚³ãƒ­ã‚’æŒ¯ã£ã¦ãã ã•ã„ï¼å„ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦æŒ¯ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
      <button onclick="autoResolveCombat()">è‡ªå‹•æˆ¦é—˜</button>
    </p>
    <p>
      ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä½“åŠ›: <span id="player-combat-health">0</span> |
      ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ <span id="monster-type">X</span> ä½“åŠ›: <span id="monster-combat-health">0</span>
    </p>
    <button onclick="rollPlayerDice()">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚µã‚¤ã‚³ãƒ­: <span id="player-dice">0</span></button>
    <button onclick="rollMonsterDice()">ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®ã‚µã‚¤ã‚³ãƒ­: <span id="monster-dice">0</span></button>
    <p id="dice-result"></p>
  </div>

  <div id="event-log">
    <p><strong>ã‚¤ãƒ™ãƒ³ãƒˆãƒ­ã‚°:</strong></p>
    <div id="log-entries"></div>
  </div>

  <div id="letters-conquered">
    <strong>å€’ã—ãŸãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼:</strong>
    <div id="conquered-list"></div>
  </div>
<script>
  const japaneseKana = [
    "ã‚", "ã„", "ã†", "ãˆ", "ãŠ",
    "ã‹", "ã", "ã", "ã‘", "ã“",
    "ã•", "ã—", "ã™", "ã›", "ã",
    "ãŸ", "ã¡", "ã¤", "ã¦", "ã¨",
    "ãª", "ã«", "ã¬", "ã­", "ã®"
  ];

  const gameSize = 10;
  const gameGrid = document.getElementById("game");

  let player = { x: 0, y: 0, hp: 100, armor: 0, coins: 0, maxHp: 100 };
  let currentLevel = 0;
  let monsters = [], treasures = [], potions = [], walls = [], stairs = {};
  let currentMonster = null;
  let playerRolled = false, monsterRolled = false, autoResolving = false;
  let defeatedLetters = {};

  let soundEnabled = true;

  const labels = {
    "ãƒ—": "ãƒ—ã¯ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼",
    "å®": "å®ã¯å®ç‰©",
    "è–¬": "è–¬ã¯å›å¾©è–¬",
    "éš": "éšã¯æ¬¡ã®éšæ®µ"
  };

  const kanaWords = {
    "ã‚": "ã‚ã¯ã‚¢ã‚¤ã‚¹ã‚¯ãƒªãƒ¼ãƒ ", "ã„": "ã„ã¯ã„ã¬", "ã†": "ã†ã¯ã†ã•ã", "ãˆ": "ãˆã¯ãˆã‚“ã´ã¤", "ãŠ": "ãŠã¯ãŠã«ãã‚Š",
    "ã‹": "ã‹ã¯ã‹ã•", "ã": "ãã¯ãã¤ã­", "ã": "ãã¯ãã˜ã‚‰", "ã‘": "ã‘ã¯ã‘ã‚€ã—", "ã“": "ã“ã¯ã“ã¾",
    "ã•": "ã•ã¯ã•ã‹ãª", "ã—": "ã—ã¯ã—ã‚“ã‹ã‚“ã›ã‚“", "ã™": "ã™ã¯ã™ã„ã‹", "ã›": "ã›ã¯ã›ã¿", "ã": "ãã¯ãã‚‰",
    "ãŸ": "ãŸã¯ãŸã“", "ã¡": "ã¡ã¯ã¡ãš", "ã¤": "ã¤ã¯ã¤ã", "ã¦": "ã¦ã¯ã¦ã¶ãã‚", "ã¨": "ã¨ã¯ã¨ã‘ã„",
    "ãª": "ãªã¯ãªã™", "ã«": "ã«ã¯ã«ã‚“ã˜ã‚“", "ã¬": "ã¬ã¯ã¬ã„ãã‚‹ã¿", "ã­": "ã­ã¯ã­ã“", "ã®": "ã®ã¯ã®ã‚Š"
  };

  const toggleAccordion = () => {
    const panel = document.getElementById("instructions");
    panel.style.display = panel.style.display === "block" ? "none" : "block";
  };

  const toggleSound = () => {
    soundEnabled = !soundEnabled;
    document.querySelector('.sound-toggle').textContent = soundEnabled ? 'ğŸ”Š' : 'ğŸ”‡';
  };

  const speak = (text) => {
    if (!soundEnabled) return;
    const utter = new SpeechSynthesisUtterance(text);
    utter.lang = "ja-JP";
    speechSynthesis.cancel();
    setTimeout(() => speechSynthesis.speak(utter), 100);
  };

  const speakAndWait = (text, callback) => {
    if (!soundEnabled) return callback();
    const utter = new SpeechSynthesisUtterance(text);
    utter.lang = "ja-JP";
    utter.onend = callback;
    speechSynthesis.cancel();
    setTimeout(() => speechSynthesis.speak(utter), 100);
  };

  const logEvent = (message) => {
    const entry = document.createElement("p");
    entry.textContent = message;
    entry.className = "log-entry";
    const last = message.split(" ").at(-1);
    if (kanaWords[last] || labels[last]) {
      entry.onclick = () => speak(kanaWords[last] || labels[last]);
    }
    const logBox = document.getElementById("log-entries");
    if (logBox) logBox.appendChild(entry);
  };

  const updateConqueredLetters = () => {
    const box = document.getElementById("conquered-list");
    box.innerHTML = '';
    Object.entries(defeatedLetters).forEach(([letter, count]) => {
      const tag = document.createElement("span");
      tag.className = "conquered-letter";
      tag.textContent = `${letter} Ã— ${count}`;
      tag.onclick = () => speak(kanaWords[letter] || letter);
      box.appendChild(tag);
    });
  };

  const rollDie = () => Math.floor(Math.random() * 20) + 1;

  const rollPlayerDice = () => {
    if (playerRolled) return;
    const result = rollDie();
    document.getElementById('player-dice').textContent = result;
    speak(`ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯ ${result} ã‚’å‡ºã—ã¾ã—ãŸ`);
    playerRolled = true;
    evaluateCombat();
  };

  const rollMonsterDice = () => {
    if (monsterRolled) return;
    const result = rollDie();
    document.getElementById('monster-dice').textContent = result;
    speak(`ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã¯ ${result} ã‚’å‡ºã—ã¾ã—ãŸ`);
    monsterRolled = true;
    evaluateCombat();
  };

  const autoResolveCombat = () => {
    if (!currentMonster) return;
    autoResolving = true;

    const loop = () => {
      if (!currentMonster || !autoResolving) return;
      const pRoll = rollDie();
      const mRoll = rollDie();
      document.getElementById('player-dice').textContent = pRoll;
      document.getElementById('monster-dice').textContent = mRoll;
      playerRolled = monsterRolled = true;

      speakAndWait(`ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯ ${pRoll} ã‚’å‡ºã—ã¾ã—ãŸ`, () => {
        speakAndWait(`ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã¯ ${mRoll} ã‚’å‡ºã—ã¾ã—ãŸ`, () => {
          evaluateCombat();
          if (currentMonster && autoResolving) setTimeout(loop, 600);
        });
      });
    };

    loop();
  };
</script>
<script>
  const evaluateCombat = () => {
    if (!playerRolled || !monsterRolled) return;

    const p = parseInt(document.getElementById("player-dice").textContent);
    const m = parseInt(document.getElementById("monster-dice").textContent);

    if (p >= m) {
      currentMonster.hp -= 20;
      if (currentMonster.hp <= 0) {
        const kana = currentMonster.type;
        defeatedLetters[kana] = (defeatedLetters[kana] || 0) + 1;
        updateConqueredLetters();
        logEvent(`ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ ${kana} ã‚’å€’ã—ãŸï¼`);
        monsters = monsters.filter(mon => mon !== currentMonster);
        player.maxHp += 10;
        player.hp += 10;
        document.getElementById('status').textContent = `${kana} ã‚’å€’ã—ã¾ã—ãŸï¼`;
        hideDice();
        autoResolving = false;
      } else {
        logEvent(`ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ ${currentMonster.type} ã«æ”»æ’ƒ (HP: ${currentMonster.hp})`);
        document.getElementById('status').textContent = `ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã«æ”»æ’ƒ (HP: ${currentMonster.hp})`;
        resetDice();
      }
    } else {
      if (player.armor > 0) player.armor -= 20;
      else player.hp -= 20;
      logEvent(`ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ ${currentMonster.type} ã«ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ãŸï¼ (HP: ${player.hp})`);
      document.getElementById('status').textContent = `ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ãŸï¼ (HP: ${player.hp})`;
      if (player.hp <= 0) {
        alert("ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼");
        startGame();
        return;
      }
      resetDice();
    }

    document.getElementById('health').textContent = player.hp;
    document.getElementById('armor').textContent = player.armor;
    document.getElementById('player-combat-health').textContent = player.hp;
    document.getElementById('monster-combat-health').textContent = currentMonster?.hp || 0;
  };

  const resetDice = () => {
    playerRolled = false;
    monsterRolled = false;
    document.getElementById('player-dice').textContent = "0";
    document.getElementById('monster-dice').textContent = "0";
  };

  const showDice = () => {
    document.getElementById("dice-game").style.display = "block";
    document.getElementById("monster-type").textContent = currentMonster.type;
    document.getElementById("player-combat-health").textContent = player.hp;
    document.getElementById("monster-combat-health").textContent = currentMonster.hp;
    resetDice();
  };

  const hideDice = () => {
    document.getElementById("dice-game").style.display = "none";
    currentMonster = null;
  };

  const drawGrid = () => {
    gameGrid.innerHTML = '';
    for (let y = 0; y < gameSize; y++) {
      for (let x = 0; x < gameSize; x++) {
        const cell = document.createElement("div");
        cell.className = "cell";

        if (x === player.x && y === player.y) {
          cell.classList.add("player");
          cell.textContent = "ãƒ—";
          cell.onclick = () => speak(labels["ãƒ—"]);
        } else if (monsters.some(m => m.x === x && m.y === y)) {
          const m = monsters.find(m => m.x === x && m.y === y);
          cell.classList.add("monster");
          cell.textContent = m.type;
          const hp = m.hp;
          const atk = 10 + japaneseKana.indexOf(m.type);
          cell.onclick = () => speak(`${kanaWords[m.type] || m.type}ã€ä½“åŠ› ${hp}ã€æ”»æ’ƒåŠ› ${atk}`);
        } else if (treasures.some(t => t.x === x && t.y === y)) {
          cell.classList.add("treasure");
          cell.textContent = "å®";
          cell.onclick = () => speak(labels["å®"]);
        } else if (potions.some(p => p.x === x && p.y === y)) {
          cell.classList.add("potion");
          cell.textContent = "è–¬";
          cell.onclick = () => speak(labels["è–¬"]);
        } else if (x === stairs.x && y === stairs.y) {
          cell.classList.add("stairs");
          cell.textContent = "éš";
          cell.onclick = () => speak(labels["éš"]);
        } else if (walls.some(w => w.x === x && w.y === y)) {
          cell.classList.add("wall");
        }

        gameGrid.appendChild(cell);
      }
    }
  };

  const randomPosition = (exclude = []) => {
    let pos;
    do {
      pos = { x: Math.floor(Math.random() * gameSize), y: Math.floor(Math.random() * gameSize) };
    } while (exclude.some(e => e.x === pos.x && e.y === pos.y));
    return pos;
  };

  const isReachable = (start, targets, walls) => {
    const queue = [start];
    const visited = new Set();
    const key = (p) => `${p.x},${p.y}`;
    visited.add(key(start));

    while (queue.length > 0) {
      const { x, y } = queue.shift();
      const neighbors = [
        { x: x + 1, y }, { x: x - 1, y },
        { x, y: y + 1 }, { x, y: y - 1 }
      ].filter(p => p.x >= 0 && p.y >= 0 && p.x < gameSize && p.y < gameSize && !walls.some(w => w.x === p.x && w.y === p.y));

      for (const n of neighbors) {
        const k = key(n);
        if (visited.has(k)) continue;
        visited.add(k);
        queue.push(n);
        if (targets.some(t => t.x === n.x && t.y === n.y)) return true;
      }
    }

    return false;
  };

  const generateValidLevel = () => {
    while (true) {
      const used = [{ x: 0, y: 0 }];
      let walls = Array.from({ length: 15 }, () => randomPosition(used));
      used.push(...walls);

      let monsters = Array.from({ length: 3 }, () => {
        const pos = randomPosition(used);
        used.push(pos);
        const kana = japaneseKana[Math.floor(Math.random() * (currentLevel + 1))];
        return { ...pos, hp: 30 + 10 * japaneseKana.indexOf(kana), type: kana };
      });

      let treasures = Array.from({ length: 3 }, () => {
        const pos = randomPosition(used);
        used.push(pos);
        return pos;
      });

      let potions = Array.from({ length: 2 }, () => {
        const pos = randomPosition(used);
        used.push(pos);
        return pos;
      });

      let stairs = randomPosition(used);
      used.push(stairs);

      const reachable = isReachable({ x: 0, y: 0 }, [...monsters, ...treasures, ...potions, stairs], walls);
      if (reachable) {
        return { walls, monsters, treasures, potions, stairs };
      }
    }
  };

  const triggerTreasure = () => {
    const outcome = Math.floor(Math.random() * 4);
    switch (outcome) {
      case 0: player.coins += 10; logEvent("10ã‚³ã‚¤ãƒ³ã‚’ç²å¾—ï¼"); break;
      case 1: player.armor += 20; logEvent("é˜²å¾¡ã‚¢ãƒƒãƒ—ï¼"); break;
      case 2: player.hp = Math.min(player.maxHp, player.hp + 20); logEvent("å›å¾©è–¬ã‚’ä½¿ã£ãŸï¼"); break;
      case 3:
        const kana = japaneseKana[Math.floor(Math.random() * (currentLevel + 1))];
        currentMonster = { x: player.x, y: player.y, hp: 30 + 10 * japaneseKana.indexOf(kana), type: kana };
        monsters.push(currentMonster);
        speak(kanaWords[kana] || kana);
        logEvent(`å®ç‰©ãŒãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ ${kana} ã«å¤‰ã‚ã£ãŸï¼`);
        showDice();
        return;
    }
    document.getElementById("coins").textContent = player.coins;
    document.getElementById("armor").textContent = player.armor;
    document.getElementById("health").textContent = player.hp;
  };

  const interact = (x, y) => {
    if (walls.some(w => w.x === x && w.y === y)) return;

    if (monsters.some(m => m.x === x && m.y === y)) {
      currentMonster = monsters.find(m => m.x === x && m.y === y);
      speak(kanaWords[currentMonster.type] || currentMonster.type);
      logEvent(`ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ ${currentMonster.type} ã«é­é‡ï¼`);
      showDice();
    } else if (treasures.some(t => t.x === x && t.y === y)) {
      speak(labels["å®"]);
      triggerTreasure();
      treasures = treasures.filter(t => !(t.x === x && t.y === y));
    } else if (potions.some(p => p.x === x && p.y === y)) {
      speak(labels["è–¬"]);
      player.hp = Math.min(player.maxHp, player.hp + 20);
      potions = potions.filter(p => !(p.x === x && p.y === y));
      logEvent("å›å¾©è–¬ã§ä½“åŠ›ã‚’å›å¾©ï¼");
      document.getElementById("health").textContent = player.hp;
    } else if (x === stairs.x && y === stairs.y) {
      speak(labels["éš"]);
      currentLevel = Math.min(japaneseKana.length - 1, currentLevel + 1);
      document.getElementById("level").textContent = japaneseKana[currentLevel];
      logEvent(`${japaneseKana[currentLevel]} éšã«é€²ã‚“ã `);
      startLevel();
    }
  };

  const movePlayer = (dx, dy) => {
    if (document.getElementById("dice-game").style.display === "block") return;
    const nx = player.x + dx;
    const ny = player.y + dy;
    if (nx < 0 || ny < 0 || nx >= gameSize || ny >= gameSize) return;
    if (walls.some(w => w.x === nx && w.y === ny)) return;
    player.x = nx;
    player.y = ny;
    interact(nx, ny);
    drawGrid();
  };

  const startLevel = () => {
    player.x = 0;
    player.y = 0;
    const level = generateValidLevel();
    walls = level.walls;
    monsters = level.monsters;
    treasures = level.treasures;
    potions = level.potions;
    stairs = level.stairs;
    hideDice();
    drawGrid();
  };

  const startGame = () => {
    player = { x: 0, y: 0, hp: 100, armor: 0, coins: 0, maxHp: 100 };
    currentLevel = 0;
    defeatedLetters = {};
    updateConqueredLetters();
    document.getElementById("level").textContent = japaneseKana[currentLevel];
    document.getElementById("log-entries").innerHTML = '';
    startLevel();
  };

  window.addEventListener("keydown", (e) => {
    if (e.key === "ArrowUp") movePlayer(0, -1);
    else if (e.key === "ArrowDown") movePlayer(0, 1);
    else if (e.key === "ArrowLeft") movePlayer(-1, 0);
    else if (e.key === "ArrowRight") movePlayer(1, 0);
  });

  startGame();
</script>
</body>
</html>
