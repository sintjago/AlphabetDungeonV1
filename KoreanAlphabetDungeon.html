<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ì•ŒíŒŒë²³ ë˜ì „</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
    }
    #game {
      display: grid;
      grid-template-columns: repeat(10, 40px);
      grid-template-rows: repeat(10, 40px);
      margin: 20px auto;
      border: 2px solid #333;
      width: 400px;
      height: 400px;
    }
    .cell {
      width: 40px;
      height: 40px;
      border: 1px solid #ccc;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2em;
    }
    .player { background-color: #4CAF50; color: white; }
    .monster { background-color: #f44336; color: white; }
    .treasure { background-color: #ffeb3b; color: #333; }
    .potion { background-color: #2196F3; color: white; }
    .stairs { background-color: #9C27B0; color: white; }
    .wall { background-color: #999; }
    #event-log {
      max-width: 400px;
      margin: 20px auto;
      text-align: left;
      border: 1px solid #ddd;
      padding: 10px;
      height: 100px;
      overflow-y: auto;
      background: #fefefe;
    }
    .log-entry {
      cursor: pointer;
      color: #4CAF50;
      margin: 0;
    }
    .log-entry:hover {
      text-decoration: underline;
    }
    .accordion {
      max-width: 600px;
      margin: 10px auto;
      text-align: left;
      border: 1px solid #ccc;
      background: #f9f9f9;
    }
    .accordion h3 {
      margin: 0;
      padding: 10px;
      background: #eee;
      cursor: pointer;
    }
    .accordion-content {
      display: none;
      padding: 10px;
    }
    .sound-toggle {
      cursor: pointer;
      margin-left: 10px;
    }
    #letters-conquered {
      max-width: 400px;
      margin: 20px auto;
      border: 1px solid #ccc;
      padding: 10px;
      background-color: #fafafa;
    }
    .conquered-letter {
      display: inline-block;
      margin: 4px;
      padding: 6px 10px;
      border: 1px solid #999;
      border-radius: 4px;
      cursor: pointer;
      background-color: #e0ffe0;
    }
    .conquered-letter:hover {
      background-color: #c0ffc0;
    }
  </style>
</head>
<body>
  <h1>ì•ŒíŒŒë²³ ë˜ì „</h1>

  <div class="accordion">
    <h3 onclick="toggleAccordion()">ê²Œì„ ë°©ë²•</h3>
    <div class="accordion-content" id="instructions">
      <ul>
        <li><strong>í”Œ</strong> = ì£¼ì¸ê³µ</li>
        <li><strong>ë³´</strong> = ë³´ë¬¼ìƒì</li>
        <li><strong>í¬</strong> = íšŒë³µì•½</li>
        <li><strong>ê³„</strong> = ë‹¤ìŒ ì¸µ ê³„ë‹¨</li>
        <li><strong>ê°€â€“í•˜</strong> = ëª¬ìŠ¤í„° (í´ë¦­í•˜ë©´ ì„¤ëª…ì„ ë“¤ì„ ìˆ˜ ìˆì–´ìš”!)</li>
      </ul>
      <p>ë°©í–¥í‚¤ë¡œ ì´ë™í•˜ì„¸ìš”. ì£¼ì‚¬ìœ„ë¥¼ êµ´ë ¤ ëª¬ìŠ¤í„°ì™€ ì‹¸ìš°ê³ , ë³´ë¬¼ê³¼ ì•„ì´í…œì„ ìˆ˜ì§‘í•˜ë©° ë” ê¹Šì€ ì¸µìœ¼ë¡œ ë‚´ë ¤ê°€ì„¸ìš”!</p>
    </div>
  </div>

  <div id="game"></div>

  <p id="status">ë°©í–¥í‚¤ë¡œ ë˜ì „ì„ íƒí—˜í•˜ì„¸ìš”!</p>
  <p>
    ì¸µ: <span id="level">ê°€</span> |
    ì²´ë ¥: <span id="health">100</span> |
    ë°©ì–´êµ¬: <span id="armor">0</span> |
    ë™ì „: <span id="coins">0</span>
    <span class="sound-toggle" onclick="toggleSound()">ğŸ”Š</span>
  </p>

  <div id="dice-game" style="display:none;">
    <p>
      ì£¼ì‚¬ìœ„ë¥¼ êµ´ë¦¬ì„¸ìš”! ë²„íŠ¼ì„ ëˆŒëŸ¬ ê°ê°ì˜ ì£¼ì‚¬ìœ„ë¥¼ êµ´ë¦´ ìˆ˜ ìˆì–´ìš”.
      <button onclick="autoResolveCombat()">ìë™ ì „íˆ¬</button>
    </p>
    <p>
      í”Œë ˆì´ì–´ ì²´ë ¥: <span id="player-combat-health">0</span> |
      ëª¬ìŠ¤í„° <span id="monster-type">X</span> ì²´ë ¥: <span id="monster-combat-health">0</span>
    </p>
    <button onclick="rollPlayerDice()">í”Œë ˆì´ì–´ ì£¼ì‚¬ìœ„: <span id="player-dice">0</span></button>
    <button onclick="rollMonsterDice()">ëª¬ìŠ¤í„° ì£¼ì‚¬ìœ„: <span id="monster-dice">0</span></button>
    <p id="dice-result"></p>
  </div>

  <div id="event-log">
    <p><strong>ì´ë²¤íŠ¸ ë¡œê·¸:</strong></p>
    <div id="log-entries"></div>
  </div>

  <div id="letters-conquered">
    <strong>ì²˜ì¹˜í•œ ëª¬ìŠ¤í„°:</strong>
    <div id="conquered-list"></div>
  </div>
<script>
  const koreanLetters = [
    "ê°€", "ë‚˜", "ë‹¤", "ë¼", "ë§ˆ", "ë°”", "ì‚¬", "ì•„",
    "ì", "ì°¨", "ì¹´", "íƒ€", "íŒŒ", "í•˜"
  ];

  const gameSize = 10;
  const gameGrid = document.getElementById("game");

  let player = { x: 0, y: 0, hp: 100, armor: 0, coins: 0, maxHp: 100 };
  let currentLevel = 0;
  let monsters = [], treasures = [], potions = [], walls = [], stairs = {};
  let currentMonster = null;
  let playerRolled = false, monsterRolled = false, autoResolving = false;
  let defeatedLetters = {};

  let soundEnabled = true;

  const labels = {
    "í”Œ": "í”Œì€ ì£¼ì¸ê³µ",
    "ë³´": "ë³´ëŠ” ë³´ë¬¼ìƒì",
    "í¬": "í¬ëŠ” íšŒë³µì•½",
    "ê³„": "ê³„ëŠ” ë‹¤ìŒ ì¸µìœ¼ë¡œ ê°€ëŠ” ê³„ë‹¨"
  };

  const letterWords = {
    "ê°€": "ê°€ëŠ” ê°€ë°©", "ë‚˜": "ë‚˜ëŠ” ë‚˜ë¬´", "ë‹¤": "ë‹¤ëŠ” ë‹¤ëŒì¥", "ë¼": "ë¼ëŠ” ë¼ë””ì˜¤",
    "ë§ˆ": "ë§ˆëŠ” ë§ˆëŠ˜", "ë°”": "ë°”ëŠ” ë°”ë‚˜ë‚˜", "ì‚¬": "ì‚¬ëŠ” ì‚¬ì", "ì•„": "ì•„ëŠ” ì•„ì´",
    "ì": "ìëŠ” ìë™ì°¨", "ì°¨": "ì°¨ëŠ” ì°¨í‘œ", "ì¹´": "ì¹´ëŠ” ì¹´ë©”ë¼", "íƒ€": "íƒ€ëŠ” íƒ€ì¡°",
    "íŒŒ": "íŒŒëŠ” íŒŒë„", "í•˜": "í•˜ëŠ” í•˜ëŠ˜"
  };

  const toggleAccordion = () => {
    const panel = document.getElementById("instructions");
    panel.style.display = panel.style.display === "block" ? "none" : "block";
  };

  const toggleSound = () => {
    soundEnabled = !soundEnabled;
    document.querySelector('.sound-toggle').textContent = soundEnabled ? 'ğŸ”Š' : 'ğŸ”‡';
  };

  const speak = (text) => {
    if (!soundEnabled) return;
    const utter = new SpeechSynthesisUtterance(text);
    utter.lang = "ko-KR";
    speechSynthesis.cancel();
    setTimeout(() => speechSynthesis.speak(utter), 100);
  };

  const speakAndWait = (text, callback) => {
    if (!soundEnabled) return callback();
    const utter = new SpeechSynthesisUtterance(text);
    utter.lang = "ko-KR";
    utter.onend = callback;
    speechSynthesis.cancel();
    setTimeout(() => speechSynthesis.speak(utter), 100);
  };

  const logEvent = (message) => {
    const entry = document.createElement("p");
    entry.textContent = message;
    entry.className = "log-entry";
    const last = message.split(" ").at(-1);
    if (letterWords[last] || labels[last]) {
      entry.onclick = () => speak(letterWords[last] || labels[last]);
    }
    const logBox = document.getElementById("log-entries");
    if (logBox) logBox.appendChild(entry);
  };

  const updateConqueredLetters = () => {
    const box = document.getElementById("conquered-list");
    box.innerHTML = '';
    Object.entries(defeatedLetters).forEach(([letter, count]) => {
      const tag = document.createElement("span");
      tag.className = "conquered-letter";
      tag.textContent = `${letter} Ã— ${count}`;
      tag.onclick = () => speak(letterWords[letter] || letter);
      box.appendChild(tag);
    });
  };

  const rollDie = () => Math.floor(Math.random() * 20) + 1;

  const rollPlayerDice = () => {
    if (playerRolled) return;
    const result = rollDie();
    document.getElementById('player-dice').textContent = result;
    speak(`í”Œë ˆì´ì–´ ì£¼ì‚¬ìœ„: ${result}`);
    playerRolled = true;
    evaluateCombat();
  };

  const rollMonsterDice = () => {
    if (monsterRolled) return;
    const result = rollDie();
    document.getElementById('monster-dice').textContent = result;
    speak(`ëª¬ìŠ¤í„° ì£¼ì‚¬ìœ„: ${result}`);
    monsterRolled = true;
    evaluateCombat();
  };

  const autoResolveCombat = () => {
    if (!currentMonster) return;
    autoResolving = true;

    const loop = () => {
      if (!currentMonster || !autoResolving) return;
      const pRoll = rollDie();
      const mRoll = rollDie();
      document.getElementById('player-dice').textContent = pRoll;
      document.getElementById('monster-dice').textContent = mRoll;
      playerRolled = monsterRolled = true;

      speakAndWait(`í”Œë ˆì´ì–´ ì£¼ì‚¬ìœ„: ${pRoll}`, () => {
        speakAndWait(`ëª¬ìŠ¤í„° ì£¼ì‚¬ìœ„: ${mRoll}`, () => {
          evaluateCombat();
          if (currentMonster && autoResolving) setTimeout(loop, 600);
        });
      });
    };

    loop();
  };
</script>
<script>
  const evaluateCombat = () => {
    if (!playerRolled || !monsterRolled) return;

    const p = parseInt(document.getElementById("player-dice").textContent);
    const m = parseInt(document.getElementById("monster-dice").textContent);

    if (p >= m) {
      currentMonster.hp -= 20;
      if (currentMonster.hp <= 0) {
        const letter = currentMonster.type;
        defeatedLetters[letter] = (defeatedLetters[letter] || 0) + 1;
        updateConqueredLetters();
        logEvent(`ëª¬ìŠ¤í„° ${letter} ì²˜ì¹˜!`);
        monsters = monsters.filter(mon => mon !== currentMonster);
        player.maxHp += 10;
        player.hp += 10;
        document.getElementById('status').textContent = `${letter} ëª¬ìŠ¤í„°ë¥¼ ë¬¼ë¦¬ì³¤ìŠµë‹ˆë‹¤!`;
        hideDice();
        autoResolving = false;
      } else {
        logEvent(`ëª¬ìŠ¤í„° ${currentMonster.type} íƒ€ê²© (HP: ${currentMonster.hp})`);
        document.getElementById('status').textContent = `íƒ€ê²© ì„±ê³µ (HP: ${currentMonster.hp})`;
        resetDice();
      }
    } else {
      if (player.armor > 0) player.armor -= 20;
      else player.hp -= 20;
      logEvent(`ëª¬ìŠ¤í„° ${currentMonster.type}ì—ê²Œ ë§ì•˜ìŠµë‹ˆë‹¤! (HP: ${player.hp})`);
      document.getElementById('status').textContent = `ê³µê²© ë‹¹í•¨! (HP: ${player.hp})`;
      if (player.hp <= 0) {
        alert("ê²Œì„ ì˜¤ë²„!");
        startGame();
        return;
      }
      resetDice();
    }

    document.getElementById('health').textContent = player.hp;
    document.getElementById('armor').textContent = player.armor;
    document.getElementById('player-combat-health').textContent = player.hp;
    document.getElementById('monster-combat-health').textContent = currentMonster?.hp || 0;
  };

  const resetDice = () => {
    playerRolled = false;
    monsterRolled = false;
    document.getElementById('player-dice').textContent = "0";
    document.getElementById('monster-dice').textContent = "0";
  };

  const showDice = () => {
    document.getElementById("dice-game").style.display = "block";
    document.getElementById("monster-type").textContent = currentMonster.type;
    document.getElementById("player-combat-health").textContent = player.hp;
    document.getElementById("monster-combat-health").textContent = currentMonster.hp;
    resetDice();
  };

  const hideDice = () => {
    document.getElementById("dice-game").style.display = "none";
    currentMonster = null;
  };

  const drawGrid = () => {
    gameGrid.innerHTML = '';
    for (let y = 0; y < gameSize; y++) {
      for (let x = 0; x < gameSize; x++) {
        const cell = document.createElement("div");
        cell.className = "cell";

        if (x === player.x && y === player.y) {
          cell.classList.add("player");
          cell.textContent = "í”Œ";
          cell.onclick = () => speak(labels["í”Œ"]);
        } else if (monsters.some(m => m.x === x && m.y === y)) {
          const m = monsters.find(m => m.x === x && m.y === y);
          cell.classList.add("monster");
          cell.textContent = m.type;
          const hp = m.hp;
          const atk = 10 + koreanLetters.indexOf(m.type);
          cell.onclick = () => speak(`${letterWords[m.type] || m.type}, ì²´ë ¥ ${hp}, ê³µê²©ë ¥ ${atk}`);
        } else if (treasures.some(t => t.x === x && t.y === y)) {
          cell.classList.add("treasure");
          cell.textContent = "ë³´";
          cell.onclick = () => speak(labels["ë³´"]);
        } else if (potions.some(p => p.x === x && p.y === y)) {
          cell.classList.add("potion");
          cell.textContent = "í¬";
          cell.onclick = () => speak(labels["í¬"]);
        } else if (x === stairs.x && y === stairs.y) {
          cell.classList.add("stairs");
          cell.textContent = "ê³„";
          cell.onclick = () => speak(labels["ê³„"]);
        } else if (walls.some(w => w.x === x && w.y === y)) {
          cell.classList.add("wall");
        }

        gameGrid.appendChild(cell);
      }
    }
  };

  const randomPosition = (exclude = []) => {
    let pos;
    do {
      pos = { x: Math.floor(Math.random() * gameSize), y: Math.floor(Math.random() * gameSize) };
    } while (exclude.some(e => e.x === pos.x && e.y === pos.y));
    return pos;
  };

  const isReachable = (start, targets, walls) => {
    const queue = [start];
    const visited = new Set();
    const key = (p) => `${p.x},${p.y}`;
    visited.add(key(start));

    while (queue.length > 0) {
      const { x, y } = queue.shift();
      const neighbors = [
        { x: x + 1, y }, { x: x - 1, y },
        { x, y: y + 1 }, { x, y: y - 1 }
      ].filter(p => p.x >= 0 && p.y >= 0 && p.x < gameSize && p.y < gameSize && !walls.some(w => w.x === p.x && w.y === p.y));

      for (const n of neighbors) {
        const k = key(n);
        if (visited.has(k)) continue;
        visited.add(k);
        queue.push(n);
        if (targets.some(t => t.x === n.x && t.y === n.y)) return true;
      }
    }

    return false;
  };

  const generateValidLevel = () => {
    while (true) {
      const used = [{ x: 0, y: 0 }];
      let walls = Array.from({ length: 15 }, () => randomPosition(used));
      used.push(...walls);

      let monsters = Array.from({ length: 3 }, () => {
        const pos = randomPosition(used);
        used.push(pos);
        const type = koreanLetters[Math.floor(Math.random() * (currentLevel + 1))];
        return { ...pos, hp: 30 + 10 * koreanLetters.indexOf(type), type };
      });

      let treasures = Array.from({ length: 3 }, () => {
        const pos = randomPosition(used);
        used.push(pos);
        return pos;
      });

      let potions = Array.from({ length: 2 }, () => {
        const pos = randomPosition(used);
        used.push(pos);
        return pos;
      });

      let stairs = randomPosition(used);
      used.push(stairs);

      const reachable = isReachable({ x: 0, y: 0 }, [...monsters, ...treasures, ...potions, stairs], walls);
      if (reachable) {
        return { walls, monsters, treasures, potions, stairs };
      }
    }
  };

  const triggerTreasure = () => {
    const outcome = Math.floor(Math.random() * 4);
    switch (outcome) {
      case 0: player.coins += 10; logEvent("ë™ì „ 10ê°œ íšë“!"); break;
      case 1: player.armor += 20; logEvent("ë°©ì–´êµ¬ íšë“!"); break;
      case 2: player.hp = Math.min(player.maxHp, player.hp + 20); logEvent("íšŒë³µì•½ ì‚¬ìš©!"); break;
      case 3:
        const type = koreanLetters[Math.floor(Math.random() * (currentLevel + 1))];
        currentMonster = { x: player.x, y: player.y, hp: 30 + 10 * koreanLetters.indexOf(type), type };
        monsters.push(currentMonster);
        speak(letterWords[type] || type);
        logEvent(`ë³´ë¬¼ì´ ëª¬ìŠ¤í„° ${type}ë¡œ ë³€í–ˆìŠµë‹ˆë‹¤!`);
        showDice();
        return;
    }
    document.getElementById("coins").textContent = player.coins;
    document.getElementById("armor").textContent = player.armor;
    document.getElementById("health").textContent = player.hp;
  };

  const interact = (x, y) => {
    if (walls.some(w => w.x === x && w.y === y)) return;

    if (monsters.some(m => m.x === x && m.y === y)) {
      currentMonster = monsters.find(m => m.x === x && m.y === y);
      speak(letterWords[currentMonster.type] || currentMonster.type);
      logEvent(`ëª¬ìŠ¤í„° ${currentMonster.type} ì¡°ìš°!`);
      showDice();
    } else if (treasures.some(t => t.x === x && t.y === y)) {
      speak(labels["ë³´"]);
      triggerTreasure();
      treasures = treasures.filter(t => !(t.x === x && t.y === y));
    } else if (potions.some(p => p.x === x && p.y === y)) {
      speak(labels["í¬"]);
      player.hp = Math.min(player.maxHp, player.hp + 20);
      potions = potions.filter(p => !(p.x === x && p.y === y));
      logEvent("íšŒë³µì•½ ì‚¬ìš©!");
      document.getElementById("health").textContent = player.hp;
    } else if (x === stairs.x && y === stairs.y) {
      speak(labels["ê³„"]);
      currentLevel = Math.min(koreanLetters.length - 1, currentLevel + 1);
      document.getElementById("level").textContent = koreanLetters[currentLevel];
      logEvent(`${koreanLetters[currentLevel]} ì¸µìœ¼ë¡œ ë‚´ë ¤ê°‘ë‹ˆë‹¤.`);
      startLevel();
    }
  };

  const movePlayer = (dx, dy) => {
    if (document.getElementById("dice-game").style.display === "block") return;
    const nx = player.x + dx;
    const ny = player.y + dy;
    if (nx < 0 || ny < 0 || nx >= gameSize || ny >= gameSize) return;
    if (walls.some(w => w.x === nx && w.y === ny)) return;
    player.x = nx;
    player.y = ny;
    interact(nx, ny);
    drawGrid();
  };

  const startLevel = () => {
    player.x = 0;
    player.y = 0;
    const level = generateValidLevel();
    walls = level.walls;
    monsters = level.monsters;
    treasures = level.treasures;
    potions = level.potions;
    stairs = level.stairs;
    hideDice();
    drawGrid();
  };

  const startGame = () => {
    player = { x: 0, y: 0, hp: 100, armor: 0, coins: 0, maxHp: 100 };
    currentLevel = 0;
    defeatedLetters = {};
    updateConqueredLetters();
    document.getElementById("level").textContent = koreanLetters[currentLevel];
    document.getElementById("log-entries").innerHTML = '';
    startLevel();
  };

  window.addEventListener("keydown", (e) => {
    if (e.key === "ArrowUp") movePlayer(0, -1);
    else if (e.key === "ArrowDown") movePlayer(0, 1);
    else if (e.key === "ArrowLeft") movePlayer(-1, 0);
    else if (e.key === "ArrowRight") movePlayer(1, 0);
  });

  startGame();
</script>
</body>
</html>
