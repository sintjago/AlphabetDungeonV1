<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>å­—æ¯åœ°ç‰¢</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
    }
    #game {
      display: grid;
      grid-template-columns: repeat(10, 40px);
      grid-template-rows: repeat(10, 40px);
      margin: 20px auto;
      border: 2px solid #333;
      width: 400px;
      height: 400px;
    }
    .cell {
      width: 40px;
      height: 40px;
      border: 1px solid #ccc;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2em;
    }
    .player { background-color: #4CAF50; color: white; }
    .monster { background-color: #f44336; color: white; }
    .treasure { background-color: #ffeb3b; color: #333; }
    .potion { background-color: #2196F3; color: white; }
    .stairs { background-color: #9C27B0; color: white; }
    .wall { background-color: #999; }
    #event-log {
      max-width: 400px;
      margin: 20px auto;
      text-align: left;
      border: 1px solid #ddd;
      padding: 10px;
      height: 100px;
      overflow-y: auto;
      background: #fefefe;
    }
    .log-entry {
      cursor: pointer;
      color: #4CAF50;
      margin: 0;
    }
    .log-entry:hover {
      text-decoration: underline;
    }
    .accordion {
      max-width: 600px;
      margin: 10px auto;
      text-align: left;
      border: 1px solid #ccc;
      background: #f9f9f9;
    }
    .accordion h3 {
      margin: 0;
      padding: 10px;
      background: #eee;
      cursor: pointer;
    }
    .accordion-content {
      display: none;
      padding: 10px;
    }
    .sound-toggle {
      cursor: pointer;
      margin-left: 10px;
    }
    #letters-conquered {
      max-width: 400px;
      margin: 20px auto;
      border: 1px solid #ccc;
      padding: 10px;
      background-color: #fafafa;
    }
    .conquered-letter {
      display: inline-block;
      margin: 4px;
      padding: 6px 10px;
      border: 1px solid #999;
      border-radius: 4px;
      cursor: pointer;
      background-color: #e0ffe0;
    }
    .conquered-letter:hover {
      background-color: #c0ffc0;
    }
  </style>
</head>
<body>
  <h1>å­—æ¯åœ°ç‰¢</h1>

  <div class="accordion">
    <h3 onclick="toggleAccordion()">æ€ä¹ˆç©</h3>
    <div class="accordion-content" id="instructions">
      <ul>
        <li><strong>ç©</strong> = ç©å®¶</li>
        <li><strong>å®</strong> = å®è—</li>
        <li><strong>è¯</strong> = è¯æ°´</li>
        <li><strong>æ¥¼</strong> = æ¥¼æ¢¯ï¼ˆä¸‹ä¸€å±‚ï¼‰</li>
        <li><strong>æ±‰å­—</strong> = æ€ªç‰©ï¼ˆç‚¹å‡»å¯å¬å‘éŸ³ï¼‰</li>
      </ul>
      <p>ä½¿ç”¨ç®­å¤´é”®ç§»åŠ¨ã€‚æ·éª°å­ä¸æ€ªç‰©æˆ˜æ–—ï¼Œæ”¶é›†å®è—ä¸é“å…·ï¼Œè¿›å…¥æ›´æ·±å±‚ï¼</p>
    </div>
  </div>

  <div id="game"></div>

  <p id="status">ä½¿ç”¨ç®­å¤´é”®å¼€å§‹æ¢ç´¢ï¼</p>
  <p>
    å±‚æ•°: <span id="level">æˆ‘</span> |
    ç”Ÿå‘½å€¼: <span id="health">100</span> |
    æŠ¤ç”²: <span id="armor">0</span> |
    é‡‘å¸: <span id="coins">0</span>
    <span class="sound-toggle" onclick="toggleSound()">ğŸ”Š</span>
  </p>

  <div id="dice-game" style="display:none;">
    <p>
      æ·éª°å­ï¼ç‚¹å‡»æŒ‰é’®æŠ•æ·ã€‚
      <button onclick="autoResolveCombat()">è‡ªåŠ¨æˆ˜æ–—</button>
    </p>
    <p>
      ç©å®¶ç”Ÿå‘½å€¼: <span id="player-combat-health">0</span> |
      æ€ªç‰© <span id="monster-type">X</span> ç”Ÿå‘½å€¼: <span id="monster-combat-health">0</span>
    </p>
    <button onclick="rollPlayerDice()">ç©å®¶éª°å­: <span id="player-dice">0</span></button>
    <button onclick="rollMonsterDice()">æ€ªç‰©éª°å­: <span id="monster-dice">0</span></button>
    <p id="dice-result"></p>
  </div>

  <div id="event-log">
    <p><strong>äº‹ä»¶æ—¥å¿—:</strong></p>
    <div id="log-entries"></div>
  </div>

  <div id="letters-conquered">
    <strong>å·²æ‰“è´¥çš„æ€ªç‰©:</strong>
    <div id="conquered-list"></div>
  </div>
<script>
  const chineseChars = [
    "æˆ‘", "æ˜¯", "ä¸­", "å›½", "äºº", "ä½ ", "å¥½", "å­¦", "ç”Ÿ", "çš„",
    "ä¸€", "äºŒ", "ä¸‰", "å¤§", "å°", "å¤©", "åœ°", "å±±", "æ°´", "ç«",
    "é£", "é›¨", "ä¹¦", "è½¦", "ç”µ", "è¯", "å®¶", "çŒ«", "ç‹—", "çˆ±"
  ];

  const gameSize = 10;
  const gameGrid = document.getElementById("game");

  let player = { x: 0, y: 0, hp: 100, armor: 0, coins: 0, maxHp: 100 };
  let currentLevel = 0;
  let monsters = [], treasures = [], potions = [], walls = [], stairs = {};
  let currentMonster = null;
  let playerRolled = false, monsterRolled = false, autoResolving = false;
  let defeatedLetters = {};

  let soundEnabled = true;

  const labels = {
    "ç©": "ç©æ˜¯ç©å®¶",
    "å®": "å®æ˜¯å®è—",
    "è¯": "è¯æ˜¯è¯æ°´",
    "æ¥¼": "æ¥¼æ˜¯æ¥¼æ¢¯"
  };

  const letterWords = {
    "æˆ‘": "æˆ‘ æ˜¯ è‡ªå·±", "æ˜¯": "æ˜¯ å°±æ˜¯", "ä¸­": "ä¸­ å›½ ä¸­å¿ƒ", "å›½": "å›½ å®¶", "äºº": "äºº ç±»",
    "ä½ ": "ä½  å¥½", "å¥½": "å¥½ å—", "å­¦": "å­¦ ä¹ ", "ç”Ÿ": "ç”Ÿ æ´»", "çš„": "çš„ ç¡®",
    "ä¸€": "ä¸€ äºŒ ä¸‰", "äºŒ": "äºŒ æ˜¯ äºŒ", "ä¸‰": "ä¸‰ æ˜¯ æ•°å­—", "å¤§": "å¤§ å°", "å°": "å° ä¸œè¥¿",
    "å¤©": "å¤© ç©º", "åœ°": "åœ° é¢", "å±±": "å±± è„‰", "æ°´": "æ°´ æµ", "ç«": "ç« ç„°",
    "é£": "é£ å¹", "é›¨": "é›¨ ä¸‹", "ä¹¦": "ä¹¦ æœ¬", "è½¦": "è½¦ è¾†", "ç”µ": "ç”µ åŠ›",
    "è¯": "è¯ è¯­", "å®¶": "å®¶ åº­", "çŒ«": "çŒ« å–µ", "ç‹—": "ç‹— æ±ª", "çˆ±": "çˆ± å¿ƒ"
  };

  const toggleAccordion = () => {
    const panel = document.getElementById("instructions");
    panel.style.display = panel.style.display === "block" ? "none" : "block";
  };

  const toggleSound = () => {
    soundEnabled = !soundEnabled;
    document.querySelector('.sound-toggle').textContent = soundEnabled ? 'ğŸ”Š' : 'ğŸ”‡';
  };

  const speak = (text) => {
    if (!soundEnabled) return;
    const utter = new SpeechSynthesisUtterance(text);
    utter.lang = "zh-CN";
    speechSynthesis.cancel();
    setTimeout(() => speechSynthesis.speak(utter), 100);
  };

  const speakAndWait = (text, callback) => {
    if (!soundEnabled) return callback();
    const utter = new SpeechSynthesisUtterance(text);
    utter.lang = "zh-CN";
    utter.onend = callback;
    speechSynthesis.cancel();
    setTimeout(() => speechSynthesis.speak(utter), 100);
  };

  const logEvent = (message) => {
    const entry = document.createElement("p");
    entry.textContent = message;
    entry.className = "log-entry";
    const last = message.split(" ").at(-1);
    if (letterWords[last] || labels[last]) {
      entry.onclick = () => speak(letterWords[last] || labels[last]);
    }
    const logBox = document.getElementById("log-entries");
    if (logBox) logBox.appendChild(entry);
  };

  const updateConqueredLetters = () => {
    const box = document.getElementById("conquered-list");
    box.innerHTML = '';
    Object.entries(defeatedLetters).forEach(([letter, count]) => {
      const tag = document.createElement("span");
      tag.className = "conquered-letter";
      tag.textContent = `${letter} Ã— ${count}`;
      tag.onclick = () => speak(letterWords[letter] || letter);
      box.appendChild(tag);
    });
  };

  const rollDie = () => Math.floor(Math.random() * 20) + 1;

  const rollPlayerDice = () => {
    if (playerRolled) return;
    const result = rollDie();
    document.getElementById('player-dice').textContent = result;
    speak(`ç©å®¶æ·å‡º ${result}`);
    playerRolled = true;
    evaluateCombat();
  };

  const rollMonsterDice = () => {
    if (monsterRolled) return;
    const result = rollDie();
    document.getElementById('monster-dice').textContent = result;
    speak(`æ€ªç‰©æ·å‡º ${result}`);
    monsterRolled = true;
    evaluateCombat();
  };

  const autoResolveCombat = () => {
    if (!currentMonster) return;
    autoResolving = true;

    const loop = () => {
      if (!currentMonster || !autoResolving) return;
      const pRoll = rollDie();
      const mRoll = rollDie();
      document.getElementById('player-dice').textContent = pRoll;
      document.getElementById('monster-dice').textContent = mRoll;
      playerRolled = monsterRolled = true;

      speakAndWait(`ç©å®¶æ·å‡º ${pRoll}`, () => {
        speakAndWait(`æ€ªç‰©æ·å‡º ${mRoll}`, () => {
          evaluateCombat();
          if (currentMonster && autoResolving) setTimeout(loop, 600);
        });
      });
    };

    loop();
  };
</script>
<script>
  const evaluateCombat = () => {
    if (!playerRolled || !monsterRolled) return;

    const p = parseInt(document.getElementById("player-dice").textContent);
    const m = parseInt(document.getElementById("monster-dice").textContent);

    if (p >= m) {
      currentMonster.hp -= 20;
      if (currentMonster.hp <= 0) {
        const letter = currentMonster.type;
        defeatedLetters[letter] = (defeatedLetters[letter] || 0) + 1;
        updateConqueredLetters();
        logEvent(`å‡»è´¥æ€ªç‰© ${letter}`);
        monsters = monsters.filter(mon => mon !== currentMonster);
        player.maxHp += 10;
        player.hp += 10;
        document.getElementById('status').textContent = `ä½ å‡»è´¥äº† ${letter}ï¼`;
        hideDice();
        autoResolving = false;
      } else {
        logEvent(`æ”»å‡»æ€ªç‰© ${currentMonster.type} (ç”Ÿå‘½: ${currentMonster.hp})`);
        document.getElementById('status').textContent = `é€ æˆä¼¤å®³ (æ€ªç‰©ç”Ÿå‘½: ${currentMonster.hp})`;
        resetDice();
      }
    } else {
      if (player.armor > 0) player.armor -= 20;
      else player.hp -= 20;
      logEvent(`æ€ªç‰© ${currentMonster.type} æ”»å‡»äº†ä½ ï¼(ç”Ÿå‘½: ${player.hp})`);
      document.getElementById('status').textContent = `ä½ å—åˆ°ä¼¤å®³ï¼(ç”Ÿå‘½: ${player.hp})`;
      if (player.hp <= 0) {
        alert("æ¸¸æˆç»“æŸï¼");
        startGame();
        return;
      }
      resetDice();
    }

    document.getElementById('health').textContent = player.hp;
    document.getElementById('armor').textContent = player.armor;
    document.getElementById('player-combat-health').textContent = player.hp;
    document.getElementById('monster-combat-health').textContent = currentMonster?.hp || 0;
  };

  const resetDice = () => {
    playerRolled = false;
    monsterRolled = false;
    document.getElementById('player-dice').textContent = "0";
    document.getElementById('monster-dice').textContent = "0";
  };

  const showDice = () => {
    document.getElementById("dice-game").style.display = "block";
    document.getElementById("monster-type").textContent = currentMonster.type;
    document.getElementById("player-combat-health").textContent = player.hp;
    document.getElementById("monster-combat-health").textContent = currentMonster.hp;
    resetDice();
  };

  const hideDice = () => {
    document.getElementById("dice-game").style.display = "none";
    currentMonster = null;
  };

  const drawGrid = () => {
    gameGrid.innerHTML = '';
    for (let y = 0; y < gameSize; y++) {
      for (let x = 0; x < gameSize; x++) {
        const cell = document.createElement("div");
        cell.className = "cell";

        if (x === player.x && y === player.y) {
          cell.classList.add("player");
          cell.textContent = "ç©";
          cell.onclick = () => speak(labels["ç©"]);
        } else if (monsters.some(m => m.x === x && m.y === y)) {
          const m = monsters.find(m => m.x === x && m.y === y);
          cell.classList.add("monster");
          cell.textContent = m.type;
          const hp = m.hp;
          const atk = 10 + chineseChars.indexOf(m.type);
          cell.onclick = () => speak(`${letterWords[m.type] || m.type}ï¼Œç”Ÿå‘½ ${hp}ï¼Œæ”»å‡» ${atk}`);
        } else if (treasures.some(t => t.x === x && t.y === y)) {
          cell.classList.add("treasure");
          cell.textContent = "å®";
          cell.onclick = () => speak(labels["å®"]);
        } else if (potions.some(p => p.x === x && p.y === y)) {
          cell.classList.add("potion");
          cell.textContent = "è¯";
          cell.onclick = () => speak(labels["è¯"]);
        } else if (x === stairs.x && y === stairs.y) {
          cell.classList.add("stairs");
          cell.textContent = "æ¥¼";
          cell.onclick = () => speak(labels["æ¥¼"]);
        } else if (walls.some(w => w.x === x && w.y === y)) {
          cell.classList.add("wall");
        }

        gameGrid.appendChild(cell);
      }
    }
  };

  const randomPosition = (exclude = []) => {
    let pos;
    do {
      pos = { x: Math.floor(Math.random() * gameSize), y: Math.floor(Math.random() * gameSize) };
    } while (exclude.some(e => e.x === pos.x && e.y === pos.y));
    return pos;
  };

  const isReachable = (start, targets, walls) => {
    const queue = [start];
    const visited = new Set();
    const key = (p) => `${p.x},${p.y}`;
    visited.add(key(start));

    while (queue.length > 0) {
      const { x, y } = queue.shift();
      const neighbors = [
        { x: x + 1, y }, { x: x - 1, y },
        { x, y: y + 1 }, { x, y: y - 1 }
      ].filter(p => p.x >= 0 && p.y >= 0 && p.x < gameSize && p.y < gameSize && !walls.some(w => w.x === p.x && w.y === p.y));

      for (const n of neighbors) {
        const k = key(n);
        if (visited.has(k)) continue;
        visited.add(k);
        queue.push(n);
        if (targets.some(t => t.x === n.x && t.y === n.y)) return true;
      }
    }

    return false;
  };

  const generateValidLevel = () => {
    while (true) {
      const used = [{ x: 0, y: 0 }];
      let walls = Array.from({ length: 15 }, () => randomPosition(used));
      used.push(...walls);

      let monsters = Array.from({ length: 3 }, () => {
        const pos = randomPosition(used);
        used.push(pos);
        const letter = chineseChars[Math.floor(Math.random() * (currentLevel + 1))];
        return { ...pos, hp: 30 + 10 * chineseChars.indexOf(letter), type: letter };
      });

      let treasures = Array.from({ length: 3 }, () => {
        const pos = randomPosition(used);
        used.push(pos);
        return pos;
      });

      let potions = Array.from({ length: 2 }, () => {
        const pos = randomPosition(used);
        used.push(pos);
        return pos;
      });

      let stairs = randomPosition(used);
      used.push(stairs);

      const reachable = isReachable({ x: 0, y: 0 }, [...monsters, ...treasures, ...potions, stairs], walls);
      if (reachable) {
        return { walls, monsters, treasures, potions, stairs };
      }
    }
  };

  const triggerTreasure = () => {
    const outcome = Math.floor(Math.random() * 4);
    switch (outcome) {
      case 0: player.coins += 10; logEvent("è·å¾—10é‡‘å¸ï¼"); break;
      case 1: player.armor += 20; logEvent("è·å¾—æŠ¤ç”²ï¼"); break;
      case 2: player.hp = Math.min(player.maxHp, player.hp + 20); logEvent("å–ä¸‹è¯æ°´ï¼Œç”Ÿå‘½æ¢å¤ï¼"); break;
      case 3:
        const letter = chineseChars[Math.floor(Math.random() * (currentLevel + 1))];
        currentMonster = { x: player.x, y: player.y, hp: 30 + 10 * chineseChars.indexOf(letter), type: letter };
        monsters.push(currentMonster);
        speak(letterWords[letter] || letter);
        logEvent(`å®è—å˜æˆäº†æ€ªç‰© ${letter}ï¼`);
        showDice();
        return;
    }
    document.getElementById("coins").textContent = player.coins;
    document.getElementById("armor").textContent = player.armor;
    document.getElementById("health").textContent = player.hp;
  };

  const interact = (x, y) => {
    if (walls.some(w => w.x === x && w.y === y)) return;

    if (monsters.some(m => m.x === x && m.y === y)) {
      currentMonster = monsters.find(m => m.x === x && m.y === y);
      speak(letterWords[currentMonster.type] || currentMonster.type);
      logEvent(`ä¸æ€ªç‰© ${currentMonster.type} äº¤æˆ˜ï¼`);
      showDice();
    } else if (treasures.some(t => t.x === x && t.y === y)) {
      speak(labels["å®"]);
      triggerTreasure();
      treasures = treasures.filter(t => !(t.x === x && t.y === y));
    } else if (potions.some(p => p.x === x && p.y === y)) {
      speak(labels["è¯"]);
      player.hp = Math.min(player.maxHp, player.hp + 20);
      potions = potions.filter(p => !(p.x === x && p.y === y));
      logEvent("ä½ å–ä¸‹è¯æ°´æ¢å¤äº†ç”Ÿå‘½ï¼");
      document.getElementById("health").textContent = player.hp;
    } else if (x === stairs.x && y === stairs.y) {
      speak(labels["æ¥¼"]);
      currentLevel = Math.min(chineseChars.length - 1, currentLevel + 1);
      document.getElementById("level").textContent = chineseChars[currentLevel];
      logEvent(`è¿›å…¥ ${chineseChars[currentLevel]} å±‚`);
      startLevel();
    }
  };

  const movePlayer = (dx, dy) => {
    if (document.getElementById("dice-game").style.display === "block") return;
    const nx = player.x + dx;
    const ny = player.y + dy;
    if (nx < 0 || ny < 0 || nx >= gameSize || ny >= gameSize) return;
    if (walls.some(w => w.x === nx && w.y === ny)) return;
    player.x = nx;
    player.y = ny;
    interact(nx, ny);
    drawGrid();
  };

  const startLevel = () => {
    player.x = 0;
    player.y = 0;
    const level = generateValidLevel();
    walls = level.walls;
    monsters = level.monsters;
    treasures = level.treasures;
    potions = level.potions;
    stairs = level.stairs;
    hideDice();
    drawGrid();
  };

  const startGame = () => {
    player = { x: 0, y: 0, hp: 100, armor: 0, coins: 0, maxHp: 100 };
    currentLevel = 0;
    defeatedLetters = {};
    updateConqueredLetters();
    document.getElementById("level").textContent = chineseChars[currentLevel];
    document.getElementById("log-entries").innerHTML = '';
    startLevel();
  };

  window.addEventListener("keydown", (e) => {
    if (e.key === "ArrowUp") movePlayer(0, -1);
    else if (e.key === "ArrowDown") movePlayer(0, 1);
    else if (e.key === "ArrowLeft") movePlayer(-1, 0);
    else if (e.key === "ArrowRight") movePlayer(1, 0);
  });

  startGame();
</script>
</body>
</html>
